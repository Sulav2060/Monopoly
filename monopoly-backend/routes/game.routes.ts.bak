import express, { Request, Response } from "express";
import RoomManager from "../services/room.service";
import GameService from "../services/game.service";
import { ApiResponse, GameState } from "../types/game";

const router = express.Router();
const roomManager = RoomManager.getInstance();

// Helper function to get game and FSM by gameId
function getGameAndFSM(gameId: string | undefined) {
  if (!gameId) {
    return { game: null, fsm: null };
  }
  const fsm = roomManager.getGameFSM(gameId);
  if (!fsm) {
    return { game: null, fsm: null };
  }
  // Access game through FSM's private property via any type
  const game = (fsm as any).game;
  return { game, fsm };
}

/**
 * POST /game/:gameId/roll
 * Roll dice for the current player
 */
router.post("/:gameId/roll", (req: Request, res: Response) => {
  try {
    const { gameId } = req.params;
    const { playerId } = req.body;

    if (!playerId) {
      return res.status(400).json({
        success: false,
        error: "Missing required field: playerId",
      } as ApiResponse);
    }

    const { game, fsm } = getGameAndFSM(gameId);

    if (!game || !fsm) {
      return res.status(404).json({
        success: false,
        error: "Game not found",
      } as ApiResponse);
    }

    // Validate it's the current player's turn
    const currentPlayer = game.players[game.currentPlayerIndex];
    if (currentPlayer?.id !== playerId) {
      return res.status(400).json({
        success: false,
        error: "It is not your turn",
      } as ApiResponse);
    }

    // Transition to ROLLING state only if not already in ROLLING
    // Allow transitioning from TURN_END or INITIALIZED to ROLLING
    if (game.gameState !== GameState.ROLLING && 
        (game.gameState === GameState.TURN_END || game.gameState === GameState.INITIALIZED)) {
      fsm.transitionTo(GameState.ROLLING);
    }

    // Roll dice
    const diceRoll = fsm.rollDice();

    // Move player
    const newPosition = (currentPlayer.position + diceRoll.total) % 40;
    
    // Check if passed GO
    const passedGO = newPosition < currentPlayer.position;
    if (passedGO) {
      currentPlayer.money += 200;
    }

    fsm.movePlayer(playerId, newPosition);

    // Update game state to MOVING
    fsm.transitionTo(GameState.MOVING);

    // Attach dice roll to game for frontend
    game.lastDiceRoll = diceRoll;

    return res.status(200).json({
      success: true,
      data: game,
    } as ApiResponse);
  } catch (error: any) {
    return res.status(400).json({
      success: false,
      error: error.message,
    } as ApiResponse);
  }
});

/**
 * POST /game/:gameId/move
 * Move player to a specific position
 */
router.post("/:gameId/move", (req: Request, res: Response) => {
  try {
    const { gameId } = req.params;
    const { playerId, position } = req.body;

    if (!playerId || position === undefined) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: playerId, position",
      } as ApiResponse);
    }

    const { game, fsm } = getGameAndFSM(gameId);

    if (!game || !fsm) {
      return res.status(404).json({
        success: false,
        error: "Game not found",
      } as ApiResponse);
    }

    const player = GameService.getPlayer(game, playerId);
    if (!player) {
      return res.status(404).json({
        success: false,
        error: "Player not found",
      } as ApiResponse);
    }

    fsm.movePlayer(playerId, position);

    return res.status(200).json({
      success: true,
      data: game,
    } as ApiResponse);
  } catch (error: any) {
    return res.status(400).json({
      success: false,
      error: error.message,
    } as ApiResponse);
  }
});

/**
 * POST /game/:gameId/buy-property
 * Buy a property
 */
router.post("/:gameId/buy-property", (req: Request, res: Response) => {
  try {
    const { gameId } = req.params;
    const { playerId, propertyId } = req.body;

    if (!playerId || propertyId === undefined) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: playerId, propertyId",
      } as ApiResponse);
    }

    const { game, fsm } = getGameAndFSM(gameId);

    if (!game || !fsm) {
      return res.status(404).json({
        success: false,
        error: "Game not found",
      } as ApiResponse);
    }

    // Buy property
    GameService.buyProperty(game, playerId, propertyId);

    return res.status(200).json({
      success: true,
      data: game,
    } as ApiResponse);
  } catch (error: any) {
    return res.status(400).json({
      success: false,
      error: error.message,
    } as ApiResponse);
  }
});

/**
 * POST /game/:gameId/pay-rent
 * Pay rent to property owner
 */
router.post("/:gameId/pay-rent", (req: Request, res: Response) => {
  try {
    const { gameId } = req.params;
    const { playerId, propertyId } = req.body;

    if (!playerId || propertyId === undefined) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: playerId, propertyId",
      } as ApiResponse);
    }

    const { game, fsm } = getGameAndFSM(gameId);

    if (!game || !fsm) {
      return res.status(404).json({
        success: false,
        error: "Game not found",
      } as ApiResponse);
    }

    const property = GameService.getProperty(game, propertyId);
    if (!property) {
      return res.status(404).json({
        success: false,
        error: "Property not found",
      } as ApiResponse);
    }

    const player = GameService.getPlayer(game, playerId);
    const owner = property.owner ? GameService.getPlayer(game, property.owner) : null;

    if (!player || !owner) {
      return res.status(400).json({
        success: false,
        error: "Player or owner not found",
      } as ApiResponse);
    }

    const rentAmount = GameService.calculateRent(property);
    
    // Transfer money
    if (!fsm.updatePlayerMoney(playerId, -rentAmount)) {
      // Player bankrupt
      owner.money += player.money;
      player.money = 0;
    } else {
      owner.money += rentAmount;
    }

    // Attach rent amount to game for frontend
    game.lastRentPaid = rentAmount;

    return res.status(200).json({
      success: true,
      data: game,
    } as ApiResponse);
  } catch (error: any) {
    return res.status(400).json({
      success: false,
      error: error.message,
    } as ApiResponse);
  }
});

/**
 * POST /game/:gameId/buy-house
 * Buy a house for a property
 */
router.post("/:gameId/buy-house", (req: Request, res: Response) => {
  try {
    const { gameId } = req.params;
    const { playerId, propertyId } = req.body;

    if (!playerId || propertyId === undefined) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: playerId, propertyId",
      } as ApiResponse);
    }

    const { game, fsm } = getGameAndFSM(gameId);

    if (!game || !fsm) {
      return res.status(404).json({
        success: false,
        error: "Game not found",
      } as ApiResponse);
    }

    // Buy house
    GameService.buyHouse(game, playerId, propertyId);

    return res.status(200).json({
      success: true,
      data: game,
    } as ApiResponse);
  } catch (error: any) {
    return res.status(400).json({
      success: false,
      error: error.message,
    } as ApiResponse);
  }
});

/**
 * POST /game/:gameId/buy-hotel
 * Buy a hotel for a property (replaces 4 houses)
 */
router.post("/:gameId/buy-hotel", (req: Request, res: Response) => {
  try {
    const { gameId } = req.params;
    const { playerId, propertyId } = req.body;

    if (!playerId || propertyId === undefined) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: playerId, propertyId",
      } as ApiResponse);
    }

    const { game, fsm } = getGameAndFSM(gameId);

    if (!game || !fsm) {
      return res.status(404).json({
        success: false,
        error: "Game not found",
      } as ApiResponse);
    }

    const property = GameService.getProperty(game, propertyId);
    const player = GameService.getPlayer(game, playerId);

    if (!property || !player) {
      return res.status(404).json({
        success: false,
        error: "Property or player not found",
      } as ApiResponse);
    }

    if (property.owner !== playerId) {
      return res.status(400).json({
        success: false,
        error: "You do not own this property",
      } as ApiResponse);
    }

    if (property.houses < 4) {
      return res.status(400).json({
        success: false,
        error: "Must have 4 houses before buying a hotel",
      } as ApiResponse);
    }

    if (player.money < property.basePricePerHotel) {
      return res.status(400).json({
        success: false,
        error: "Insufficient funds",
      } as ApiResponse);
    }

    property.houses = 0;
    property.hotels = 1;
    player.money -= property.basePricePerHotel;

    return res.status(200).json({
      success: true,
      data: game,
    } as ApiResponse);
  } catch (error: any) {
    return res.status(400).json({
      success: false,
      error: error.message,
    } as ApiResponse);
  }
});

/**
 * POST /game/:gameId/end-turn
 * End current player's turn
 */
router.post("/:gameId/end-turn", (req: Request, res: Response) => {
  try {
    const { gameId } = req.params;
    const { playerId } = req.body;

    if (!playerId) {
      return res.status(400).json({
        success: false,
        error: "Missing required field: playerId",
      } as ApiResponse);
    }

    const { game, fsm } = getGameAndFSM(gameId);

    if (!game || !fsm) {
      return res.status(404).json({
        success: false,
        error: "Game not found",
      } as ApiResponse);
    }

    // Validate it's the current player's turn
    const currentPlayer = game.players[game.currentPlayerIndex];
    if (currentPlayer?.id !== playerId) {
      return res.status(400).json({
        success: false,
        error: "It is not your turn",
      } as ApiResponse);
    }

    // Transition to TURN_END state first
    fsm.transitionTo(GameState.TURN_END);

    // Advance to next player
    fsm.nextTurn();

    // Check if game is over
    if (fsm.isGameOver()) {
      fsm.transitionTo(GameState.GAME_OVER);
      const winner = fsm.getWinner();
      // Attach game over info to game for frontend
      game.gameOver = true;
      game.winner = winner;
      return res.status(200).json({
        success: true,
        data: game,
      } as ApiResponse);
    }

    // Stay in TURN_END state - let next player roll by clicking roll button
    // The rollDice endpoint will handle transitioning from TURN_END â†’ ROLLING

    return res.status(200).json({
      success: true,
      data: game,
    } as ApiResponse);
  } catch (error: any) {
    return res.status(400).json({
      success: false,
      error: error.message,
    } as ApiResponse);
  }
});

/**
 * GET /game/:gameId
 * Get current game state
 */
router.get("/:gameId", (req: Request, res: Response) => {
  try {
    const { gameId } = req.params;

    const { game, fsm } = getGameAndFSM(gameId);

    if (!game || !fsm) {
      return res.status(404).json({
        success: false,
        error: "Game not found",
      } as ApiResponse);
    }

    return res.status(200).json({
      success: true,
      data: game,
    } as ApiResponse);
  } catch (error: any) {
    return res.status(500).json({
      success: false,
      error: error.message,
    } as ApiResponse);
  }
});

export default router;
